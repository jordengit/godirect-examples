<html>
<head>
  <meta charset="utf-8">
  <script src="godirect.min.umd.js"></script>
  <script src="FileSaver.min.js"></script>
  <script src="chart.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
  <div style="float: left; width: 30%;">
    <button id="select_device" onclick="selectDevice()">Select Go Direct Device</button><br />
    <button id="start_stop_collection" onclick="startStopCollection()">Start Collection</button><br />
    samplerate<input type="number" name="samplerate" id="samplerate" value="10" style="width: 80px;">&nbsp;ms<br />
    <button id="btnStart" onclick="start()">Start</button><br />
    <button id="btnEnd" onclick="end()">End</button><br />
    <button id="btnSave" onclick="save()">Save</button><br />
    <button id="btnDraw" onclick="draw()">Draw</button><br />
    <span id="dur">0</span> &nbsp;ms<br />
    <span id="measurements">0</span> &nbsp;measurements<br />
  </div>
  <div style="float: left; width: 400px;height: 400px;">
      <div style="min-width: 150px;max-width: 400px; max-height: 400px; min-height: 150px;">
        <canvas id="myChart"></canvas>
      </div>
  </div>
  <pre id="output" style="height: 300px;overflow: auto;width: 60%;"></pre>

  <script >
    // setup the calculator
    let toggleCollect = false;
    let collectcount = 0;
    let collectary = [];
    let savedata = [];

    let startts = 0;
    let endts = 0;

    let collecting = false;
    let delta = 1.0;

    const selectDeviceBtn = document.querySelector('#select_device');
    const collectBtn = document.querySelector('#start_stop_collection');
    const output = document.querySelector('#output');
    const txtdur = document.querySelector('#dur');
    const txtmeasurements = document.querySelector('#measurements');
    const valsamplerate = document.querySelector('#samplerate');

    let gdxDevice;

    const selectDevice = async () => {
      try {
        if (gdxDevice){
          gdxDevice.close();
        } else {
        // connect to the gdx device
        const bleDevice = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'GDX' }],
          optionalServices: ['d91714ef-28b9-4f91-ba16-f0d9a604f112']
        });

        // Create the device but don't open or start measurements.
        gdxDevice = await godirect.createDevice(bleDevice,  {open: false, startMeasurements: false});

         // print that the device is disconnected
         gdxDevice.on('device-closed', () => {
           output.textContent += `\n\n Disconnected from `+gdxDevice.name+`\n`;
           gdxDevice = undefined;
           selectDeviceBtn.textContent = `Select Go Direct Device`;
         });


         gdxDevice.on('device-opened', () => {
          output.textContent += `\n Connected to `+gdxDevice.name;
          output.textContent += `\n Press start to start collection \n`;
          output.textContent += `\n If you can't see your sensor values on the graph right away, \n Zoom out of the graph in the Desmos Window \n`;

          selectDeviceBtn.textContent = `Disconnect from ${gdxDevice.name}`;

          const sensor = gdxDevice.sensors[0];
          sensor.setEnabled(true);
            sensor.on('value-changed', (sensor) => {
              let y = sensor.value;
              let ts = new Date().getTime();
              collectcount++;
              if(collectcount >= 100000) collectcount = 0;
              collectary.push({'v': y.toPrecision(4), 't': ts});
            });
         });

         gdxDevice.open(false);
        }
      } catch (err) {
        console.error(err);
      }
    };
     // start collection function
     const startStopCollection = async () => {
       if (!collecting) {
          collecting = true;
          collectBtn.textContent = `Stop Collection`;
          let samplerate = valsamplerate.value * 1;
          gdxDevice.start(delta * samplerate);
        } else {
          collecting = false;
          collectBtn.textContent = `Start Collection`;
          gdxDevice.stop();
        }
      };

      const start = async () => {
        startts = new Date().getTime();
        endts = 0;
      }

      const end = async () => {
        endts = new Date().getTime();
        savedata = collectary.filter(o => o.t > startts && o.t < endts);

        let dur = endts - startts;
        txtdur.textContent = dur;
        txtmeasurements.textContent = savedata.length;
      }

      const draw = async () => {
        const ctx = document.getElementById('myChart');

        const data = {
          //labels: savedata.map(o=>new Date(o.t).toJSON().replace('T', ' ').replace('Z', '')),
          labels: savedata.map((o, i) => i),
          datasets: [{
            label: 'My First dataset',
            backgroundColor: '#00FF0066',
            borderColor: '#00FF0000',
            fill: false,
            data: savedata.map(o=>o.v),
          }]
        };

        // chart = new Chart(ctx, {
        //     type: 'line',
        //     data: data,
        //     options: {
        //         scales: {
        //             x: {
        //                 type: 'timeseries',
        //                 time: {
        //                     unit: 'millisecond'
        //                 }
        //             }
        //         }
        //     }
        // });
        if (Chart.getChart("myChart")) Chart.getChart("myChart").destroy()
        chart = new Chart(ctx, {
            type: 'line',
            data: data,
            options: {
              responsive: true,
              plugins: {
                legend: {
                  position: 'top',
                },
                title: {
                  display: true,
                  text: 'Chart.js Line Chart'
                }
              }
            },
        });
      }
      let chart = null;
      const save = async () => {
        // Save content to a file

        let summarydata = savedata.reduce((res, o)=>res += `${o.t} => ${o.v}\n`, "");

        var blob = new Blob([summarydata], { type: "text/plain;charset=ascii" });
        saveAs(blob, "data.txt");
      }

      const save1 = async () => {
        // Save content to a file

        let summarydata = summmary.reduce((res, o)=>res += `${o.t} => ${o.v}\n`, "");

        var blob = new Blob([summarydata], { type: "text/plain;charset=ascii" });
        saveAs(blob, "data.txt");
      }

  </script>
</body>
</html>
